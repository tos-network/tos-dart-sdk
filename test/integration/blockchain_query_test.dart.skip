@Tags(['integration'])
library;

import 'package:test/test.dart';
import 'package:tos_dart_sdk/tos_dart_sdk.dart';

void main() {
  group('Blockchain Query Integration Tests', () {
    late DaemonClient client;

    setUp(() {
      client = DaemonClient(
        endPoint: testnetNodeURL,
        secureWebSocket: true,
      );
      client.connect();
    });

    tearDown(() {
      client.disconnect();
    });

    test('should get top block from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final topBlock = await client.getTopBlock();

      expect(topBlock, isNotNull);
      expect(topBlock.hash, isNotEmpty);
      expect(topBlock.blueScore, greaterThan(0));
      expect(topBlock.blockType, isNotEmpty);
      expect(topBlock.timestamp, greaterThan(0));
      expect(topBlock.version, greaterThan(0));

      print('Top Block Hash: ${topBlock.hash}');
      print('Blue Score: ${topBlock.blueScore}');
      print('Block Type: ${topBlock.blockType}');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get block at specific topoheight', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      // Get a stable topoheight first
      final stableTopoheight = await client.getStableTopoHeight();
      final topoheight = stableTopoheight - 100; // Go back 100 blocks

      final block = await client.getBlockAtTopoHeight(
        GetBlockAtTopoHeightParams(topoheight: topoheight),
      );

      expect(block, isNotNull);
      expect(block.hash, isNotEmpty);
      expect(block.blueScore, greaterThan(0));

      print('Block at topoheight $topoheight: ${block.hash}');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get blocks at blue score', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      // Get current blue score
      final blueScore = await client.getBlueScore();
      final targetBlueScore = blueScore - 50; // Go back 50 blue scores

      final blocks = await client.getBlocksAtBlueScore(
        GetBlocksAtBlueScoreParams(blueScore: targetBlueScore),
      );

      expect(blocks, isNotNull);
      expect(blocks, isNotEmpty);

      for (final block in blocks) {
        expect(block.blueScore, equals(targetBlueScore));
        expect(block.hash, isNotEmpty);
      }

      print('Found ${blocks.length} blocks at blue score $targetBlueScore');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get tips from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final tips = await client.getTips();

      expect(tips, isNotNull);
      expect(tips, isNotEmpty);

      for (final tip in tips) {
        expect(tip, isNotEmpty);
      }

      print('Found ${tips.length} tips');
      print('Tips: $tips');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get difficulty from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final difficulty = await client.getDifficulty();

      expect(difficulty, isNotNull);
      expect(difficulty.difficulty, isNotEmpty);
      expect(difficulty.hashrate, greaterThanOrEqualTo(0));

      print('Difficulty: ${difficulty.difficulty}');
      print('Hashrate: ${difficulty.hashrate}');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get dev fee thresholds', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final thresholds = await client.getDevFeeThresholds();

      expect(thresholds, isNotNull);
      expect(thresholds.fee05, greaterThanOrEqualTo(0));
      expect(thresholds.fee1, greaterThanOrEqualTo(0));
      expect(thresholds.fee15, greaterThanOrEqualTo(0));
      expect(thresholds.fee2, greaterThanOrEqualTo(0));

      print('Fee 0.5%: ${thresholds.fee05}');
      print('Fee 1.0%: ${thresholds.fee1}');
      print('Fee 1.5%: ${thresholds.fee15}');
      print('Fee 2.0%: ${thresholds.fee2}');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get assets from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final assets = await client.getAssets();

      expect(assets, isNotNull);
      expect(assets, isNotEmpty);

      // TOS asset should always be present
      final tosAssetFound = assets.any(
        (asset) => asset.asset == tosAsset,
      );
      expect(tosAssetFound, isTrue);

      print('Found ${assets.length} assets on testnet');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should count assets on testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final count = await client.countAssets();

      expect(count, greaterThanOrEqualTo(1)); // At least TOS asset
      print('Total assets: $count');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should count accounts on testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final count = await client.countAccounts();

      expect(count, greaterThanOrEqualTo(0));
      print('Total accounts: $count');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should count transactions on testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final count = await client.countTransactions();

      expect(count, greaterThanOrEqualTo(0));
      print('Total transactions: $count');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get mempool from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final mempool = await client.getMempool();

      expect(mempool, isNotNull);
      expect(mempool, isA<List>());

      print('Mempool size: ${mempool.length}');

      if (mempool.isNotEmpty) {
        final firstTx = mempool.first;
        print('First tx hash: ${firstTx.hash}');
      }
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get peers from testnet', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final peers = await client.getPeers();

      expect(peers, isNotNull);
      expect(peers, isA<List>());

      print('Connected peers: ${peers.length}');

      if (peers.isNotEmpty) {
        final firstPeer = peers.first;
        print('First peer: ${firstPeer.addr}');
      }
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get size on disk', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final size = await client.getSizeOnDisk();

      expect(size, greaterThan(0));

      // Convert to GB for readability
      final sizeGB = size / (1024 * 1024 * 1024);
      print('Blockchain size on disk: ${sizeGB.toStringAsFixed(2)} GB');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should validate valid TOS address', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      // This is a valid testnet address format (example)
      const validAddress = 'tos1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9dm50j';

      final result = await client.validateAddress(
        ValidateAddressParams(address: validAddress),
      );

      expect(result, isNotNull);
      expect(result.isValid, isA<bool>());

      print('Address valid: ${result.isValid}');
    }, timeout: const Timeout(Duration(seconds: 10)));

    test('should get hard forks info', () async {
      await Future<void>.delayed(const Duration(seconds: 1));

      final hardForks = await client.getHardForks();

      expect(hardForks, isNotNull);
      expect(hardForks, isA<List>());

      print('Hard forks count: ${hardForks.length}');

      if (hardForks.isNotEmpty) {
        for (final fork in hardForks) {
          print('Hard fork at height ${fork.height}: version ${fork.version}');
        }
      }
    }, timeout: const Timeout(Duration(seconds: 10)));
  });
}
